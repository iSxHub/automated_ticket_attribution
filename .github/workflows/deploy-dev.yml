name: deploy-dev

on:
  push:
    tags:
      - "*-dev"

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-dev
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    env:
      PYTHONHASHSEED: "0"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Ensure tag commit is on dev branch
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin dev --prune

          TAG_COMMIT="$(git rev-parse HEAD)"
          echo "[guard] tag=${GITHUB_REF_NAME} commit=${TAG_COMMIT}"
          echo "[guard] verifying commit is contained in origin/dev..."

          if ! git merge-base --is-ancestor "${TAG_COMMIT}" "origin/dev"; then
            echo "::error::Tag ${GITHUB_REF_NAME} points to ${TAG_COMMIT}, which is NOT on origin/dev. Create the tag from dev." >&2
            exit 1
          fi

      - name: Setup Python + deps
        uses: ./.github/actions/setup-python-deps
        with:
          python-version: "3.10"

      - name: Quality gates
        shell: bash
        run: |
          set -euo pipefail
          make ci

      - name: Log deploy context
        shell: bash
        run: |
          set -euo pipefail
          echo "[deploy] tag=${GITHUB_REF_NAME}"
          echo "[deploy] region=${{ vars.AWS_REGION }}"
          echo "[deploy] ecr_repo=${{ vars.ECR_REPO }}"
          echo "[deploy] bucket=${{ vars.DEPLOY_BUCKET }}"
          echo "[deploy] instance=${{ vars.DEV_EC2_INSTANCE_ID }}"
          echo "[deploy] ssm_path=${{ vars.SSM_PATH }}"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Build & push Docker image to ECR
        shell: bash
        run: |
          set -euo pipefail

          TAG="${GITHUB_REF_NAME}"
          AWS_REGION="${{ vars.AWS_REGION }}"

          AWS_ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID }}"
          ECR_REPO="${{ vars.ECR_REPO }}"
          : "${AWS_ACCOUNT_ID:?Missing vars.AWS_ACCOUNT_ID}"
          : "${ECR_REPO:?Missing vars.ECR_REPO}"
          : "${AWS_REGION:?Missing vars.AWS_REGION}"

          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          IMAGE_URI="${ECR_REGISTRY}/${ECR_REPO}:${TAG}"

          echo "[ecr] registry=${ECR_REGISTRY}"
          echo "[ecr] repo=${ECR_REPO}"
          echo "[ecr] image_uri=${IMAGE_URI}"

          aws ecr get-login-password --region "${AWS_REGION}" \
            | docker login --username AWS --password-stdin "${ECR_REGISTRY}"

          docker build -t "${IMAGE_URI}" .
          docker push "${IMAGE_URI}"

          echo "IMAGE_URI=${IMAGE_URI}" >> "$GITHUB_ENV"

      - name: Package source (deploy bundle)
        shell: bash
        run: |
          set -euo pipefail
          chmod +x deploy/build_bundle.sh
          deploy/build_bundle.sh "${GITHUB_REF_NAME}"

      - name: Upload deploy bundle artifact (optional)
        uses: actions/upload-artifact@v4
        with:
          name: deploy-bundle-${{ github.ref_name }}
          path: atta-${{ github.ref_name }}.tar.gz
          if-no-files-found: error
          retention-days: 7

      - name: Upload artifact to S3
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          BUCKET="${{ vars.DEPLOY_BUCKET }}"
          : "${BUCKET:?Missing vars.DEPLOY_BUCKET}"

          echo "[s3] uploading bundle to s3://${BUCKET}/atta/${TAG}/atta-${TAG}.tar.gz"
          aws s3 cp "atta-${TAG}.tar.gz" "s3://${BUCKET}/atta/${TAG}/atta-${TAG}.tar.gz"

      - name: Deploy on EC2 via SSM Run Command (download bundle + run deploy + wait)
        shell: bash
        run: |
          set -euo pipefail

          TAG="${GITHUB_REF_NAME}"
          INSTANCE_ID="${{ vars.DEV_EC2_INSTANCE_ID }}"
          AWS_REGION="${{ vars.AWS_REGION }}"
          BUCKET="${{ vars.DEPLOY_BUCKET }}"

          # Read from env populated in ECR step
          ATTA_IMAGE="${IMAGE_URI}"

          # Optional repo var; fallback to /atta/dev
          SSM_PATH="${{ vars.SSM_PATH }}"
          if [[ -z "${SSM_PATH}" ]]; then
            SSM_PATH="/atta/dev"
          fi

          : "${INSTANCE_ID:?Missing vars.DEV_EC2_INSTANCE_ID}"
          : "${AWS_REGION:?Missing vars.AWS_REGION}"
          : "${ATTA_IMAGE:?Missing IMAGE_URI env (Build step failed?)}"
          : "${BUCKET:?Missing vars.DEPLOY_BUCKET}"

          echo "[ssm] instance=${INSTANCE_ID}"
          echo "[ssm] region=${AWS_REGION}"
          echo "[ssm] bucket=${BUCKET}"
          echo "[ssm] ssm_path=${SSM_PATH}"
          echo "[ssm] image=${ATTA_IMAGE}"

          PARAMS_JSON="$(python deploy/render_ssm_payload.py \
            --tag "${TAG}" \
            --aws-region "${AWS_REGION}" \
            --atta-image "${ATTA_IMAGE}" \
            --bucket "${BUCKET}" \
            --ssm-path "${SSM_PATH}"
          )"

          COMMAND_ID="$(
            aws ssm send-command \
              --instance-ids "${INSTANCE_ID}" \
              --document-name "AWS-RunShellScript" \
              --comment "Deploy ATTA ${TAG}" \
              --parameters "${PARAMS_JSON}" \
              --query "Command.CommandId" \
              --output text
          )"

          echo "SSM CommandId=${COMMAND_ID}"

          aws ssm wait command-executed --command-id "${COMMAND_ID}" --instance-id "${INSTANCE_ID}" || true

          INVOCATION_JSON="$(
            aws ssm get-command-invocation \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --output json
          )"

          STATUS="$(python -c 'import json,sys; print(json.load(sys.stdin).get("Status",""))' <<< "${INVOCATION_JSON}")"
          STDOUT="$(python -c 'import json,sys; print(json.load(sys.stdin).get("StandardOutputContent",""))' <<< "${INVOCATION_JSON}")"
          STDERR="$(python -c 'import json,sys; print(json.load(sys.stdin).get("StandardErrorContent",""))' <<< "${INVOCATION_JSON}")"

          echo "----- SSM STATUS -----"
          echo "${STATUS}"
          echo "----- SSM STDOUT -----"
          echo "${STDOUT}"
          echo "----- SSM STDERR -----"
          echo "${STDERR}"

          if [[ "${STATUS}" != "Success" ]]; then
            echo "::error::SSM command failed with status: ${STATUS}" >&2
            exit 1
          fi